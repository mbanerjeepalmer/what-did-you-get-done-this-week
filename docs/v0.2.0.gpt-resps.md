Nice brief — this is a perfect fit for Argos. Below I’ll:

* Propose a robust design that matches your scenarios (A–E).
* Answer your seven open questions (with sources).
* Give a ready-to-drop-in Argos plugin (`what-did-you-get-done.1m.sh`) that:

  * runs every minute,
  * schedules 15-minute prompts,
  * posts desktop notifications (best-effort across daemons),
  * provides menu actions (Respond / Dismiss / Snooze),
  * writes responses to per-day files (user-configurable directory),
  * writes calendar events (using either `gcalcli` / Google API or CalDAV / Microsoft Graph — explained below).
* Explain assumptions, limitations, and recommended improvements.

If you want, I can also convert the calendar-writing part into a Python helper (Google/Microsoft auth flows are easiest handled in Python).

---

# Design summary (behavior to satisfy A–E)

Key ideas:

* The Argos plugin runs frequently (1 minute) and keeps a small state file (in `~/.cache/argos-whatgotdone/state`) containing:

  * `next_due` (timestamp when next prompt should be issued),
  * `notified_at` (timestamp when a currently outstanding notification was shown),
  * `snoozed_until` (timestamp if the user snoozed),
  * `last_response` (optional).
* When `now >= next_due` **and** not snoozed, the plugin:

  * creates a desktop notification (best effort) and records `notified_at`.
  * exposes Argos menu items (Respond / Dismiss / Snooze) that run commands to respond/dismiss/snooze.
* If the user responds:

  * the script records the *actual response time* (not the scheduled time),
  * appends a line to the day file,
  * creates a calendar event whose start time = response time minus 15 minutes and end time = response time (so “stretches 15 minutes into the past”),
  * sets `next_due = response_time + 15 minutes`.
* If the user dismisses:

  * do nothing to storage (no file/calendar entries),
  * set `next_due = notified_at + 15 minutes` (i.e. next prompt 15 min after the notification).
* If the user doesn’t see the notification immediately (scenario C or D):

  * there is only one outstanding notification tracked by `notified_at`. When they later respond, we use that later time as response time and schedule the next prompt 15 minutes after the response (scenario C).
  * if > 15 minutes pass and they come back, they will see only the still-outstanding notification (scenario D).
* Snooze behaviour:

  * setting `snoozed_until` suppresses new prompts until that timestamp,
  * if the user “wakes” the app before snooze expiry (scenario E) — i.e. clears the snooze — the next check will see `now >= next_due` and send a prompt immediately.

This approach matches all scenarios A–E and avoids stacking many notifications because we only ever create one outstanding notification and track `notified_at`. (How to remove the old notification depends on notification daemon support — see below.)

---

# Argos plugin (bash) — drop in `~/.config/argos/what-did-you-get-done.1m.sh`

Save the file below and `chmod +x`. Filename uses `1m` so Argos runs it every minute; the script itself implements 15-minute logic and state management.

```bash
#!/usr/bin/env bash
# what-did-you-get-done.1m.sh
# Put in ~/.config/argos and make executable.
#
# Behavior:
# - Runs every minute (Argos interval) but enforces 15-minute prompts using state file.
# - Uses notify-send for notification (best-effort) and uses zenity for textual input via menu.
# - Appends entries to daily files and (optionally) calls calendar helper commands.

set -euo pipefail

# --- CONFIG: change these if you want ---
DIR="${WHATGOTDONE_DIR:-$HOME/what-did-you-get-done-this-week}"
STATE_DIR="${WHATGOTDONE_STATE_DIR:-$HOME/.cache/what-got-done}"
STATE_FILE="$STATE_DIR/state"
NOTIFY_SUMMARY="What did you get done?"
NOTIFY_BODY="Click Respond in the Argos menu or use the Respond button (if your desktop supports actions)."
NOTIFICATION_APP_NAME="what-got-done"
# calendar helper: set to a command that accepts: CALENDAR_CMD "start_iso" "end_iso" "title"
# Examples:
# - gcalcli:  gcalcli add --calendar 'MyCalendar' --title "TITLE" --when "START/END"
# - python helper that uses Google Calendar API
CALENDAR_CMD="${WHATGOTDONE_CAL_CMD:-}"   # empty = disabled by default
CALENDAR_NAME="${WHATGOTDONE_CAL_NAME:-default}"  # optional calendar name for helper
# --- end config ---

mkdir -p "$DIR"
mkdir -p "$STATE_DIR"

# helper: iso datetime with timezone, RFC3339-like (YYYY-MM-DDTHH:MM:SS±HH:MM)
iso_now() { date -Iseconds; }

# safe read/write state
# state is simple: key=value lines
read_state() {
  if [ -f "$STATE_FILE" ]; then
    # shell-safe read
    . "$STATE_FILE"
  else
    NEXT_DUE=""
    NOTIFIED_AT=""
    SNOOZED_UNTIL=""
    LAST_RESPONSE=""
  fi
}

write_state() {
  cat > "$STATE_FILE" <<EOF
NEXT_DUE="$NEXT_DUE"
NOTIFIED_AT="$NOTIFIED_AT"
SNOOZED_UNTIL="$SNOOZED_UNTIL"
LAST_RESPONSE="$LAST_RESPONSE"
EOF
}

now_epoch() { date +%s; }
epoch_to_iso() { date -d "@$1" -Iseconds; }  # GNU date

# initialize state if empty
read_state
if [ -z "${NEXT_DUE:-}" ]; then
  # start prompting immediately (or you could start after 15 min)
  NEXT_DUE="$(now_epoch)"
fi

# helper: send notification (best-effort)
send_notification() {
  local id body summary actions
  summary="$1"; body="$2"
  # basic notify
  notify-send --app-name="$NOTIFICATION_APP_NAME" "$summary" "$body" || true
  # Note: notify-send actions aren't widely supported in all notification daemons.
}

# helper: create per-day file entry (tab-separated: ISO_DATETIME<TAB>ENTRY)
append_to_file() {
  local when_iso="$1"; local entry="$2"
  local dayfile
  dayfile="$DIR/$(date -d "$when_iso" +%Y-%m-%d).txt"
  # Use a tab delimiter for robust machine readability.
  printf "%s\t%s\n" "$when_iso" "$entry" >> "$dayfile"
}

# helper: create calendar event via CALENDAR_CMD if configured
create_calendar_event() {
  if [ -z "$CALENDAR_CMD" ]; then
    return 0
  fi
  local start_iso="$1" end_iso="$2" title="$3"
  # You must provide a command that accepts these args.
  # For example a small Python script that calls Google Calendar API, or
  # a wrapper that uses gcalcli or caldav.
  "$CALENDAR_CMD" "$CALENDAR_NAME" "$start_iso" "$end_iso" "$title" || true
}

# respond flow invoked by Argos menu or manual run
respond_flow() {
  # open zenity prompt for input (blocks)
  RESPONSE="$(zenity --entry --title='What did you get done?' --text='Describe what you accomplished:' 2>/dev/null || true)"
  if [ -z "$RESPONSE" ]; then
    # either cancelled or empty - treat as dismiss
    return 1
  fi
  # actual timestamp
  RESP_EPOCH="$(now_epoch)"
  RESP_ISO="$(epoch_to_iso "$RESP_EPOCH")"
  # append to file
  append_to_file "$RESP_ISO" "$RESPONSE"
  # calendar event: 15 minutes into the past -> event start = resp - 15min, end = resp
  START_EPOCH=$((RESP_EPOCH - 15*60))
  START_ISO="$(epoch_to_iso "$START_EPOCH")"
  END_ISO="$RESP_ISO"
  create_calendar_event "$START_ISO" "$END_ISO" "$RESPONSE"
  # schedule next due 15 minutes after response
  NEXT_DUE="$((RESP_EPOCH + 15*60))"
  NOTIFIED_AT=""
  LAST_RESPONSE="$RESP_ISO"
  write_state
  return 0
}

# dismiss flow: user dismisses notification or clicks Dismiss menu item
dismiss_flow() {
  # schedule next due 15 minutes after notified_at (if set) or after now
  local base_epoch
  if [ -n "${NOTIFIED_AT:-}" ]; then
    base_epoch="$(date -d "$NOTIFIED_AT" +%s)"
  else
    base_epoch="$(now_epoch)"
  fi
  NEXT_DUE="$((base_epoch + 15*60))"
  NOTIFIED_AT=""
  write_state
}

# snooze flow: ask for a time (e.g. "16:00" or minutes)
snooze_flow() {
  ANSWER="$(zenity --entry --title='Snooze until' --text='Enter snooze until time (e.g. 16:00 or YYYY-MM-DD HH:MM or +30m):' 2>/dev/null || true)"
  if [ -z "$ANSWER" ]; then
    return 1
  fi
  # try to parse with date -d
  SNOOZED_EPOC=$(date -d "$ANSWER" +%s 2>/dev/null || true)
  if [ -z "$SNOOZED_EPOC" ]; then
    # maybe it's +Xm
    if [[ "$ANSWER" =~ ^\+([0-9]+)m$ ]]; then
      addmin="${BASH_REMATCH[1]}"
      SNOOZED_EPOC=$(( $(now_epoch) + addmin*60 ))
    else
      zenity --error --text="Could not parse time: $ANSWER" 2>/dev/null || true
      return 1
    fi
  fi
  SNOOZED_UNTIL="$(epoch_to_iso "$SNOOZED_EPOC")"
  # keep NEXT_DUE as-is; snooze prevents notifications until SNOOZED_UNTIL
  write_state
}

# If script called with action parameters (Argos menu can call the script with parameters)
# e.g. what-did-you-get-done.1m.sh respond
if [ "${1:-}" = "respond" ]; then
  read_state
  respond_flow
  exit 0
fi
if [ "${1:-}" = "dismiss" ]; then
  read_state
  dismiss_flow
  exit 0
fi
if [ "${1:-}" = "snooze" ]; then
  read_state
  snooze_flow
  exit 0
fi

# ---- main run (Argos output) ----
read_state

# Print top-level button (shown in panel)
echo "What got done? | length=20"
echo "---"

# Menu: show next due and last response
if [ -n "${NEXT_DUE:-}" ]; then
  echo "Next due: $(epoch_to_iso "$NEXT_DUE")"
else
  echo "Next due: (unset)"
fi
if [ -n "${LAST_RESPONSE:-}" ]; then
  echo "Last: $LAST_RESPONSE"
fi

echo "---"
# Actions exposed in the menu:
# Respond (opens zenity), Dismiss, Snooze
# Argos runs these commands when clicked.
THIS_SCRIPT="$(readlink -f "$0")"
echo "Respond now | bash='$THIS_SCRIPT' param1=respond terminal=false refresh=true"
echo "Dismiss | bash='$THIS_SCRIPT' param1=dismiss terminal=false refresh=true"
echo "Snooze... | bash='$THIS_SCRIPT' param1=snooze terminal=false refresh=true"

# Now scheduling logic (runs invisibly)
NOW_EPOCH=$(now_epoch)

# if snoozed and still in future, show snoozed status and do nothing
if [ -n "${SNOOZED_UNTIL:-}" ]; then
  SNOOZED_EPOCH=$(date -d "$SNOOZED_UNTIL" +%s)
  if [ "$NOW_EPOCH" -lt "$SNOOZED_EPOCH" ]; then
    # still snoozed: show quick menu hint
    echo "---"
    echo "Snoozed until: $SNOOZED_UNTIL | color=gray"
    exit 0
  else
    # snooze expired
    SNOOZED_UNTIL=""
    write_state
  fi
fi

# If it's time to notify and we haven't already shown a notification (no outstanding)
if [ "$NOW_EPOCH" -ge "$NEXT_DUE" ] && [ -z "${NOTIFIED_AT:-}" ]; then
  # send notification (best-effort)
  send_notification "$NOTIFY_SUMMARY" "$NOTIFY_BODY"
  NOTIFIED_AT="$(epoch_to_iso "$NOW_EPOCH")"
  write_state
  exit 0
fi

# Nothing else to do; exit
exit 0
```

### How to use this plugin

* Put in `~/.config/argos` and `chmod +x`.
* Optional environment variables:

  * `WHATGOTDONE_DIR` to set directory for daily files (defaults to `~/what-did-you-get-done-this-week`),
  * `WHATGOTDONE_CAL_CMD` to set calendar helper command (see notes below),
  * `WHATGOTDONE_CAL_NAME` calendar id/name for helper.
* Click the Argos menu item to Respond (which opens a Zenity prompt), Dismiss, or Snooze.

---

# Answers to your Open Questions

## 1) Calendar interfaces: Outlook/Google — is there a simpler user-friendly CLI?

Short answer: there are several options; none are *magic* — you will need an API or a client tool.

* **Google Calendar**

  * `gcalcli` is a mature command-line client that can add events and is simple to script with; under the hood it uses the Google Calendar API and requires OAuth setup once. It’s convenient for scripts. ([GitHub][1])
  * For full control and production use, the **Google Calendar API** (OAuth2) is the robust route; you’ll likely write a small helper (Python recommended) to handle tokens and create events. Google’s quickstarts and client libraries are well-documented. ([Google for Developers][2])
* **Outlook / Exchange / Microsoft 365**

  * Use **Microsoft Graph API**. It’s the canonical API for creating calendar events programmatically and supports creating events in specific calendars. Requires an Azure app and OAuth. For scripts, there are libraries (msal, Microsoft Graph SDKs) and even PowerShell cmdlets for Graph. ([Microsoft Learn][3])
* **CalDAV**

  * If the calendar supports CalDAV (Nextcloud, many providers), you can use a Python CalDAV library to create events. Good if you control the server or use a CalDAV-compatible service. ([caldav][4])

Recommendation: for personal use, start with `gcalcli` (fast to wire up). For organization / Exchange, use Microsoft Graph (or `O365` Python packages). If you self-host Nextcloud/CalDAV, use a small CalDAV Python helper.

## 2) Correct interface for notifications on Ubuntu / GNOME?

* The common CLI is `notify-send` (libnotify) to send notifications. It’s widely available but **has limited support for action buttons** across different notification daemons. Many daemons ignore action buttons or don’t offer direct input in the notification itself. ([Unix & Linux Stack Exchange][5])
* GNOME/GJS supports `GNotification` and the Freedesktop notifications D-Bus API (`org.freedesktop.Notifications`) for richer notifications and actions. Writing a small GJS (or Python/GLib) helper can let you attach actions that invoke commands, but behavior still depends on the underlying notification daemon. MDN docs also document the `actions` array for web notifications. ([MDN Web Docs][6])
* **Argos itself does not auto-open the system notification tray**; it controls the dropdown menu and can expose menu items in the panel. Use Argos menu items for guaranteed interaction (Respond / Snooze) and notifications as *alerts only*.

Practical rule: use notifications as alerts only and provide a guaranteed input path via Argos menu items (which are reliable). If you want clickable buttons in notifications, you’ll need to detect and support the user’s notification daemon (unreliable across environments).

## 3) How should input work? OS-level or Argos-level?

* **Best cross-desktop UX**: use an Argos menu action (Argos menu item `bash=...`) to open a GTK dialog (Zenity, Yad) or a small GTK/GJS window for text input. This is reliable because Argos menu actions always work. (The plugin above uses `zenity --entry`.)
* **Notification-level input** (typing into notification) is not widely supported. Some desktop stacks (or extensions) allow notification action buttons (you can open a custom dialog from an action), but it's inconsistent. So *don’t rely on it* for primary input. Use the Argos menu / Zenity approach as the canonical input channel. ([Medium][7])

## 4) Exactly what should the datetime format be?

Recommendation: use **RFC3339 / ISO8601 with timezone offset**, e.g.

```
2025-09-11T15:23:12+01:00
```

This is both human-readable and machine-parsable. In GNU `date` you can get a close format with `date -Iseconds` (or `date --iso-8601=seconds`). Use that for file entries and for calendar event timestamps. (Script above uses `date -Iseconds`/`date -d` conversions.) ([Google for Developers][2])

## 5) How should the datetime and entry be separated? Are two spaces enough?

* **Don’t use ambiguous whitespace.** Use a **tab** (`\t`) or a clear delimiter like `\t` or `|`.
* I recommend **TAB** between timestamp and text for robust machine readability while remaining human-friendly:

```
2025-09-11T15:23:12+01:00<TAB>Wrote the weekly report and sent to Bob
```

This avoids accidental collisions if user text contains multiple spaces. The example plugin uses a tab.

## 6) How should scheduling work with Argos?

* **Let Argos run frequently (1m)** and let the plugin manage its own schedule state. Reason:

  * Argos can run plugins at intervals, but Argos’s interval granularity and menu-open re-run options are useful. Running every minute and storing `next_due` in state is robust and lets you implement snooze and outstanding-notification behavior easily.
  * Running exactly every 15 minutes via Argos filename (e.g. `15m`) could work, but you’d lose the ability to track an outstanding notification’s `notified_at` and handle late responses (scenario C) robustly.
* So the plugin approach above (Argos 1m + internal state) is the recommended pattern. Argos’s asynchronous execution engine handles scripts that take time, and menu clicks can run the same script with parameters. ([extensions.gnome.org][8])

## 7) How to avoid stacking notifications?

Options and recommendation:

* **Keep a single outstanding notification** and track `notified_at` in the plugin’s state; don’t post a new notification until either (a) the user responds/dismisses, or (b) you choose to re-notify after some repeat interval.
* **Replacing/removing old notifications** requires D-Bus notification IDs and depends on the daemon. Some clients that call `org.freedesktop.Notifications.Notify` get back a notification id and later call `CloseNotification(id)` to remove it. That’s doable from a small helper program but not from plain `notify-send` reliably. So:

  * **Practical**: post one notification and rely on menu actions to handle respond/dismiss/snooze. If you *must* replace a notification, use a small helper that uses the Freedesktop notifications D-Bus API and keeps the notification id to explicitly close/replace notifications (advanced).
  * If you want the old notification to be removed and replaced automatically, implement a D-Bus wrapper for notifications (GJS or Python + `dbus`/`pydbus`) that stores the `id` and calls `CloseNotification`. ([Unix & Linux Stack Exchange][5])

---

# Limitations & recommended improvements

1. **Notification actions / inline input**: unreliable across different notification daemons. Rely on Argos menu + zenity for reliable input; treat notifications as alerts only. This is the most pragmatic approach. ([Ask Ubuntu][9])

2. **Calendar auth**: writing to remote calendars (Google, Outlook) requires OAuth/service account configuration and a helper script/program (Python is easiest). For `gcalcli` you’ll do one-time OAuth setup and then call it from the plugin; for Graph API you’ll create an Azure app and either use delegated OAuth or an app-level credential. I can provide a Python helper that wraps Google or Microsoft Graph flows if you want.

3. **Time parsing for snooze**: the script uses `date -d` (GNU date) to parse human times; that’s good but not perfectly robust. You can also accept “+Xm” formats as shown.

4. **Edge cases**: if the machine sleeps/wakes, the script’s `next_due` semantics still work because we use epoch timestamps. If you want perfect accounting across timezone changes, make sure to store epoch and convert to ISO when writing.

---

# Useful references (quick)

* `gcalcli` — command-line Google Calendar client. Good quick start for scripting Google calendar updates. ([GitHub][1])
* Google Calendar API quickstart & client libraries (Python recommended). ([Google for Developers][2])
* Microsoft Graph API calendar endpoints (create event). Use for Outlook/Exchange/M365 integration. ([Microsoft Learn][3])
* CalDAV Python library: useful if you have a CalDAV-compatible calendar (Nextcloud, Radicale). ([caldav][4])
* Notification action support and limitations: `notify-send` vs D-Bus API; actions vary by daemon; consider a D-Bus helper for replace/close. ([Unix & Linux Stack Exchange][5])
* Zenity (or `yad`) for quick GTK input dialogs from shell scripts. ([LFCS Certification eBook][10])

---

# Next steps I can do for you (pick any)

* Provide a **Python calendar helper** that authenticates to Google Calendar and exposes a simple CLI `gcal_helper calendar_name start_iso end_iso "title"` that you wire into `WHATGOTDONE_CAL_CMD`. (Recommended.)
* Add a **D-Bus notification helper** (Python or GJS) so the plugin can create notifications with replace/close and action callbacks.
* Turn the Zenity prompt into a small GTK popup embedded in a GJS helper for a smoother look.
* Add unit tests / a small mock run log to simulate scenario C and D.

---

If you want, I’ll:

* produce the Python Google Calendar helper (OAuth + create event) next, or
* add a D-Bus notification helper that gives you replace/close and action callbacks.

Which of those would you like me to implement next?

[1]: https://github.com/insanum/gcalcli?utm_source=chatgpt.com "insanum/gcalcli: Google Calendar Command Line Interface"
[2]: https://developers.google.com/workspace/calendar/api/quickstart/python?utm_source=chatgpt.com "Python quickstart | Google Calendar"
[3]: https://learn.microsoft.com/en-us/graph/api/calendar-post-events?view=graph-rest-1.0&utm_source=chatgpt.com "Create event - Microsoft Graph v1.0"
[4]: https://caldav.readthedocs.io/stable/tutorial.html?utm_source=chatgpt.com "Tutorial - Documentation: caldav 2.0.1 - Read the Docs"
[5]: https://unix.stackexchange.com/questions/545888/setup-notify-send-click-action?utm_source=chatgpt.com "Setup notify-send click action"
[6]: https://developer.mozilla.org/en-US/docs/Web/API/Notification/actions?utm_source=chatgpt.com "Notification: actions property - Web APIs | MDN - Mozilla"
[7]: https://medium.com/%40chawalamona44/zenity-unleashed-the-ultimate-guide-to-command-line-dialog-boxes-779cbcefc33a?utm_source=chatgpt.com "The Ultimate Guide to Command-Line Dialog Boxes ..."
[8]: https://extensions.gnome.org/review/29514?utm_source=chatgpt.com "Review \"Argos\" version 4 - GNOME Shell Extensions"
[9]: https://askubuntu.com/questions/1378731/how-do-i-send-notifications-with-buttons-from-bash-script?utm_source=chatgpt.com "How do i send notifications with buttons from bash script?"
[10]: https://www.tecmint.com/zenity-create-gtk-dialog-boxes-in-linux/?utm_source=chatgpt.com "Zenity: Building GTK+ Dialogs in Shell Scripts"
